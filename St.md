# 객체

OOP
	프로그래밍 패러다임중의 하나로 프로그래밍에 필요한 데이터를 추상화시켜 객체를 만들고 그 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.

**클래스** : 어떤 문제를 해결하기 위한 데이터를 만들기기 위해 추상화를 거쳐 집단에 속하는 **속성**(attribute)과 **행위**(behavior)를 **변수**와 **메서드**로 정의한 것

**인스턴스(객체)** : 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터

추상화<br>	객체에서 공통된 속성과 행위를 추출

캡슐화
	불필요한 정보는 숨기고 중요한 정보만 표현
	내부의 구현은 감추고 모듈 내에서 응집도를 높임
	외부로의 노출을 최소화하여 모듈간의 결합도를 떨어뜨려 유연함과 유지보수성을 높임

상속
	부모의 특성과 기능을 그대로 물려받는 것
	기능의 일부를 변경 - 오버라이딩
	캡슐화를 유지하면서도 클래스의 재사용이 가능

다형성
	하나의 변수명, 함수명 등이 상황에 따라 다른 기능을 수행하는 것
	오버로딩 오버라이딩

객체지향 프로그래밍의 장점
	코드 재사용 용이 - 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장하여 사용할 수 있음
	유지보수가 쉬움
	대형 프로젝트에 적합 - 모듈화시켜서 업무 분담 후 개발

객체지향 프로그래밍의 단점
	처리속도가 상대적으로 느림
	객체가 많으면 용량이 커짐
	설계시 많은 시간과 노력이 필요

const
	const int a - 상수
	const int* a - 포인터가 가르키는것 상수
	int* const a - 포인터 자체 상수
	

	void aaa() const - 멤버 값 변경 불가능한 함수
	const AAA aaa(10) - 멤버변수 접근 불가 상수함수만 접근 가능

static
	static int a - 전역
	멤버변수 static int a - 클래스에서만 접근 가능한 전역
	int AAA::a=1; 전역변수 초기화 문법
	
virtual function
	virtual 키워드를 함수 앞에 붙임으로써 만들어지는 함수. 

가상함수 생성시 자식 클래스에게 vPtr을 맴버로 (몰래) 생성. vTable에 가상 함수와 함께 등록

단점

* 클래스 크기에 4바이트가 더 들어간다(가상 함수 포인터)
* memset 등 메모리 초기화 함수 사용 불가

순수가상함수

` void func() = 0` 형태로 생김

순수가상함수가 부모에게 있을시 자식클래스에서는 무조건 정의해주어야한다. 순수가상함수가 하나라도 있는 클래스는 추상클래스로 객체화 불가

**c++ vs java**

* c++ 다중 상속지원, java는 x
* friend(은닉성 파괴)키워드 지원 여부
* java는 interface 지원 => 다중 상속 흉내

* 메모리 처리

  * c++은 stack, heap에 모두 할당 가능
  * java는 only heap
  * 메모리 해제 자동 여부(Garbage collector vs destructor)

* 문법 및 기능

  * c++은 연산자 오버로딩 지원

  * java는 익명클래스 지원

  * 자바는 동적바인딩, c++ 정적바인딩

    but c++은 virtual 키워드 통해 동적바인딩도 지원

# 자료구조

## 배열

같은 타입을 갖는 요소들의 모임

## 링크드 리스트

노드들이 선형적으로 순서화된 형태의 집합체

각 노드들은 데이터와 next를 저장

head, tail로 처음과 끝을 가리킴

## 스택

자료를 차곡차곡 쌓아올린 형태의 자료구조

LIFO 구조 (top으로 정한 곳에서만 접근가능)

**예시**

* text 편집기 undo(ctrl + z)
* 함수 호출시 메모리 상태변화
* 예전 뒤로가기

## 큐

자료가 뒤에서 들어오고 앞에서 빠져나가는 형태의 자료구조

FIFO(front, rear)

작업 스케쥴링

## 트리

부모 자식관계로 이루어진 노드의 집합

### 순회

* 전위 순회 : 자기 자신 방문 후, 자식 노드

  ``` 
  preorder(a)
  	visit(a)
  	for each child of a:
  		preorder(child)
  ```

  

* 후위 순회: 자식 노드 방문후, 자신 방문

  ```
  postorder(a)
  	for each child of a:
  		postorder(child)
  	visit(a)
  ```

  

## Map, Dictionary

(key, value)쌍으로 저장되는 자료구조

* hash table 로 구현

  o(n) worst case

  o(1) best case

* 레드블랙트리

## Heap

힙(heap)은 완전 이진 트리의 일종으로 부모 노드와 자식 노드간에 항상 대소관계가 성립하는 자료구조. 최대 최소 찾기 편한 자료구조

max-heap: 부모가 더 큼

min-heap: 부모가 더 작음

* 삽입: 맨 아래 오른쪽에 삽입 후 up-heap
* 삭제: down-heap

### 구현

- 완전 이진 트리는 `배열로 구현`합니다.
- 구현을 쉽게 하기 위해 배열을 사용할 때 인덱스는 `1`부터 사용합니다.
- 특정 노드의 배열 인덱스가 `current`라고 한다면 `부모 노드`는 `current / 2`를 통해 찾아갈 수 있고 `자식 노드`는 `current * 2`(좌측 자식 노드) 또는 `current * 2 + 1`(우측 자식 노드)을 통해서 찾아갈 수 있습니다.
- 현재 노드 인덱스 : `current`
- 부모 노드 인덱스 : `current / 2`
- 자식 노드들 인덱스 (순서 대로 좌우) : `current * 2`, `current * 2 + 1`

## Priority Queue

들어간 순서에 상관없이 우선 순위에 따라 결과가 달라지는 자료구조

* 배열로 구현 : 삽입, 삭제 둘중 하나가 o(n) 정렬됬는지 안됐는지에 따라 달라짐
* 링크드 리스트: 삽입 o(1), 삭제 o(n)
* heap 구현: 삽입,삭제가 lg n

## BST

이진탐색트리란 이진탐색(binary search)과 연결리스트(linked list)를 결합한 자료구조의 일종입니다. 이진탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제를 가능하게끔 고안.

# OS

운영체제 - 컴퓨터 하드웨어 관리해주는 프로그램

인터럽트 - 하드웨어가 시스템 수행 흐름 바꾸기 위해 발생.

소프트웨어는 system call이라는 특정 연산을 실행하여 일부러 발생시키거나 자발적으로 발생

인터럽트 발생시 현재 작업을 멈추고 상태 보관 -> interrupt vetor이용하여 interrupt service routin찾음 -> 인터럽트 수행 -> 보관된 상태 원상복귀.

DMA - 입출력 장치 속도가 빠르면 인터럽트 발생이 빈번함. -> 장치 제어기가 cpu 관련 없이 직접 주기억 장치로 이동. 인터럽트는 블록단위로 발생

프로세스 - 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것을 말한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다.

스레드는 프로세스의 실행 단위라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다.  -> 응답성(일부 블록 나머지 실행), 자원공유, 경제성

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다. 스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다.

system call - 프로세스와 운영체제 간에 인터페이스를 제공. 

PCB 는 특정 **프로세스에 대한 중요한 정보를 저장** 하고 있는 운영체제의 자료구조이다. 운영체제는 프로세스를 관리하기 위해 **프로세스의 생성과 동시에 고유한 PCB 를 생성** 한다. 프로세스는 CPU 를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU 를 반환해야 하는데, 이때 작업의 진행 상황을 모두 PCB 에 저장하게 된다. 그리고 다시 CPU 를 할당받게 되면 PCB 에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다.

멀티스레딩 장점 - 메모리 공간과 시스템 자원 소모 줄어듬. 통신 시에 heap 영역을 통해 서로 공유 가능. context switching시에 캐쉬를 비울필요가 없어서 더 빠르다.(캐쉬에 명령어들이 올라가있는데 같은 프로세스의 명령어기 때문에 비울 필요 x) 따라서 시스템의 throughtput 이 향상되고 자원 소모가 줄어들며 자연스럽게 프로그램의 응답 시간이 단축

### 스케쥴링

* cpu utilization
* throughput 시간당 완료되는 프로세스 수
* turnaround time
* waiting time : 준비완료 큐에서 대기한 시간(첫 프로세스 실행 시 다시 대기한다면 그것도 포함시켜야됌)
* responste time: 서비스 요청 후 첫 실행까지 시간

#### FCFS(First Come First Served)

- 먼저 온 고객을 먼저 서비스해주는 방식, 즉 먼저 온 순서대로 처리.
- 비선점형(Non-Preemptive) 스케줄링

- convoy effect
  소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.

### SJF(Shortest - Job - First)

- 다른 프로세스가 먼저 도착했어도 CPU burst time 이 짧은 프로세스에게 선 할당
- 비선점형(Non-Preemptive) 스케줄링
- 평균 대기시간에서 최적

- starvation

#### SRT(Shortest Remaining time First)

- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
- 선점형 (Preemptive) 스케줄링
  현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.

- starvation
- 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.

#### Priority Scheduling

- 우선순위가 가장 높은 프로세스에게 CPU 를 할당하겠다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
- 선점형 스케줄링(Preemptive) 방식
  더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.
- 비선점형 스케줄링(Non-Preemptive) 방식
  더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣는다.

- starvation

- aging
  아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주자.

#### Round Robin

- 현대적인 CPU 스케줄링
- 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다.
- `RR`은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
- `RR`이 가능한 이유는 프로세스의 context 를 save 할 수 있기 때문이다.

- `Response time`이 빨라진다.
  즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.

설정한 `time quantum`이 너무 커지면 `FCFS`와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다. 그렇기 때문에 적당한 `time quantum`을 설정하는 것이 중요하다.

#### 다중레벨 큐

* 준비 큐를 여러개의 큐로 나누어 사용
* 각 큐는 독자적인 스케쥴링 알고리즘 사용
* time slice방법으로 starvation 해결

#### 다중레벨 피드백 큐

* 큐간 스레등 가능

### 프로세스 동기화

#### Critical Section(임계영역)

멀티 스레딩에 문제점에서 나오듯, 동일한 자원을 동시에 접근하는 작업(e.g. 공유하는 변수 사용, 동일 파일을 사용하는 등)을 실행하는 코드 영역을 Critical Section 이라 칭한다.

- Mutual Exclusion(상호 배제)
  프로세스 P1 이 Critical Section 에서 실행중이라면, 다른 프로세스는 임계구역에 진입 불가해야한다.
- Progress(진행)
  Critical Section 에서 실행중인 프로세스가 없을 때, 몇 개의 프로세스가 진입하고자 하면 이들의 순서는 이들에 의해서만 결정. 무기한 연장되면 안된다.
- Bounded Waiting(한정된 대기)
  P1 가 Critical Section 에 진입 신청 후 부터 받아들여질 때가지, 다른 프로세스들이 Critical Section 에 진입하는 횟수는 제한이 있어야 한다.

#### dead lock

프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생.

### 메모리 관리 배경

각각의 **프로세스** 는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, **운영체제** 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.

**Swapping** : 메모리의 관리를 위해 사용되는 기법. 표준 Swapping 방식으로는 round-robin 과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다.

> 이 과정을 **swap** (**스왑시킨다**) 이라 한다. 주 기억장치(RAM)으로 불러오는 과정을 **swap-in**, 보조 기억장치로 내보내는 과정을 **swap-out** 이라 한다. swap 에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할때 Swapping 이 시작된다.

**단편화** (**Fragmentation**) : 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 **단편화** 이다. 단편화는 2 가지 종류로 나뉜다.

- 외부 단편화: 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 **분산되어 있을때 발생한다고 볼 수 있다.**
- 내부 단편화: 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 **메모리 분할 자유 공간이 10,000B 있고 Process A 가 9,998B 사용하게되면 2B 라는 차이** 가 존재하고, 이 현상을 내부 단편화라 칭한다.

압축 : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다. (위의 메모리 현황이 압축을 통해 아래의 그림 처럼 바뀌는 효과를 가질 수 있다)

#### Paging(페이징)

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.(페이지 교체 알고리즘에 들어가는 페이지)

페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점이 있다.

하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 **순서에 상관없이** 물리 메모리에 있는 프레임에 mapping 되어 저장된다고 볼 수 있다.

- 단점 : 내부 단편화 문제의 비중이 늘어나게 된다. 예를들어 페이지 크기가 1,024B 이고 **프로세스 A** 가 3,172B 의 메모리를 요구한다면 3 개의 페이지 프레임(1,024 * 3 = 3,072) 하고도 100B 가 남기때문에 총 4 개의 페이지 프레임이 필요한 것이다. 결론적으로 4 번째 페이지 프레임에는 924B(1,024 - 100)의 여유 공간이 남게 되는 내부 단편화 문제가 발생하는 것이다.

#### Segmentation

가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할

논리 주소는 세그먼트 번호와 변위 비트로 이루어져 있게 된다. 세그먼트 테이블에 논리 주소 값이 들어가게 되면 세그먼트 번호는 세그먼트 테이블의 인덱스 값으로 인식을 하게 된다. 세그먼트 번호를 토대로 테이블 내용으로 들어가 시작 위치 및 한계 값을 파악한다. 물리 주소는 세그먼트 테이블에 있는 시작 위치와 변위 값을 합하여 구할 수 있다. 

* 단점: 외부 단편화 문제가 생김 -> 세그먼트를 또다시 페이징기법으로 나누어 해결

## 가상 메모리

다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상메모리는 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법** 

#### 페이지 교체 알고리즘

#### FIFO 페이지 교체

가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.

- 장점
  - 이해하기도 쉽고, 프로그램하기도 쉽다.
- 단점
  - 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다(초기 변수 등)
  - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
  - `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

#### 최적 페이지 교체(Optimal Page Replacement)

`Belady의 모순`을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 `Belady의 모순`이 발생하지 않는다. 이 알고리즘의 핵심은 `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다. 주로 비교 연구 목적을 위해 사용한다.

- 장점
  - 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
- 단점
  - 구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

#### LRU 페이지 교체(LRU Page Replacement)

`LRU: Least-Recently-Used`
최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.

- 특징
  - 대체적으로 `FIFO 알고리즘`보다 우수하고, `OPT알고리즘`보다는 그렇지 못한 모습을 보인다.

#### LFU 페이지 교체(LFU Page Replacement)

`LFU: Least Frequently Used`
참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.

- 특징
  - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다
  - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

#### MFU 페이지 교체(MFU Page Replacement)

`MFU: Most Frequently Used`
참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.

- 특징
  - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

# 전공 질문 

### MVC

mvc 이전의 전통적인 방법

* 개발 속도가 빠르고 개발자의 스킬이 낮아도 배우기 쉽다.
* 한 페이지가 너무 복잡해진다.
* 개발자와 디자이너의 분리작업이 어려워진다.
* 유지보수 어렵다.

mvc 는 각각의 역할을 나누어 작업하고자 하는 일을 분담.

* controller - 클라이언트 요청을 받았을 때 그 요청에 대해 실제 업무 수행하는 컴포넌트 호출. 클라이언트 보낸 데이터를 모델에 전달하기 쉽게 가공. 모델이 업무를 마치면 그 결과를 뷰에 전달
* model - 컨트롤러 호출 시, 요청에 맞는 역할 수행. 비즈니스 로직 구현 영역으로 데이터 처리하는 부분.
* view - 결과갑을 통해 사용자에게 출력할 화면 생성

## JS

JS엔진은 stack, task queue, heap 영역으로 나뉨. js 엔진은 javascript로 작성한 코드 해석하고 실행하는 인프리터

* call - stack : 자바스크립트는 단 하나의 호출 스택을 사용.(하나 함수 실행시 다른 task 수행 불가)
* heap - 동적으로 생성된 객체는 힘에 할당
* queue - 처리해야 하는 task들 임시 저장

### hoisting

변수의 정의가 그 범위에 따라 선언과 할당으로 분리, 즉 변수가 함수 내에 정의 되었을 경우, 선언이 함수의 최상위로. 함수 바깥에서 정의되었을 경우, 전역 컨텍스트의 최상위로 변경이 됨.



js 대부분 작업이 비동기로 이루어짐.

-> async/await 비동기 코드를 작성하는 새로운 방법

기존엔 promise 사용 but 규모가 커지면 어려워짐

### Arrow function

간결하게 함수를 표현. 항상 익명이며 자신의 this, super등을 바인딩하지 않기 때문에 사용자로서 사용 x

## Front-end

### 브라우저 동작원리

1.html 마크업 처리, dom 트리 빌드(무엇을 그릴지 결정)

2.css 마크업 처리하고 cssos트리 빌드(어떻게 그릴지 결정)

3.dom및 cssom결합 렌더링 트리 형성(화면에 그려질 것만 결정)

### CORS

리소스 요청시 해당 리소스는 cross-origin http요청에 의해 요청된다.

### 클라이언트 사이드 렌더링 & 서버 사이드 렌더링

웹 페이지, 모바일 웹에 대한 기능 -> single page web app

spa는 브라우저에 로드되고 난 뒤 페이지 전체를 서버에 요청하는 것이아니라, 한번 페이지 전체 로딩 후 데이터만 변경하요 사용하는 웹앱. 전통적인 웹 방식(서버 사이드) 보다 성능 좋음.

spa는 트래픽을 감소시키고 더 나은 경험 제공. 서버는 단지 json 파일 보내주는 역할을 했고, html은 클라이언트 측에서 자바스크립트가 수행하게 된것. 클라이언트 쪽이 느려지자 이에 반대로 view 만 관리하자는 철학으로 react가 등장.

## NOSQL

현재 not only sql로 설명. 기존의 관계형 db특성 뿐만 아니라 다른 특성도 부가적으로 지원. 융통성있는 데이터 모델 사용하고 저장 및 검색을 위한 특화된 메커니즘 제공. 단순 검색 및 추가작업에 있어서 키 값 저장을 통해 빠른 응답속도와 처리효율 보임

## React

ui를 만드는 자바스크립트 라이브러리.

가장 큰 특징은 UI를 여러 컴포넌트로 쪼갠다.여러 화면에서 재사용 가능

**DOM**: document object model. <html><body> 같은 html 문서 태그들을 객체로 만듬. document 객체와 관련된 객체의 집합

html 파일을 웹브라우저에서 오픈 -> dom 생성 -> 브라우저에서 표시. => 보통 dom을 조작하여 웹을 동적으로 구성 => 조작시 dom 재시작으로 시간도 오래걸리고 자원도 많이 먹음

=> react는 가상의 dom을 만들고 변경사항이 있을때마다 전체가 아닌 부븐의 dom에만 반영.

react는 view 의 값을 view에서 변경하지 못하고 state를 거쳐서 다시 와야하는 구조

## Docker

컨테이너 기반 오픈소스 가상화 플랫폼

기존의 os 가상화: host os 위에 guest os를 두어 성능에 문제가 있음 

호스트와 OS자원 공유. host os와 컨테이너의 os 의 다른 부분만 container안에 같이 패킹됨. container 내 명령어 수행시 실제로는 host os에서 명령어 수행. 즉 host os의 process공간 공유.

계층화된 파일 시스템 사용하기 때문에 가상화된 컨테이너 변경사항 모두 축적하고 관리. 따라서 필요시 언제 어디서나 실행 가능

도커파일: DSL언어 이용하여 생성. 서버에 프로그램 설치위해 의존성 패키지 설치 필요없이 dockerfile로 관리

이미지: 컨테이너 실행에 필요한 파일과 설정값 (유니온 파일시스템을 통한 레이어)

## KUBERNETES

### kubernetes란

컨테이너 운영환경을 돕는 솔루션

### 마스터와 노드

마스터: 쿠버네티스 클러스터 전체를 컨트롤하는 시스템 api 서버, 스케쥴러, 컨트롤러 매니져, etcd로 구성

노드: 마스터에 의해 명령을 받고 실제 워크로드를 생성하여 서비스하는 컴포넌트. kubelet, kube-proxy,cAdvisor 등이 포함

kubelet - 마스터의 api서버와 통신하며, 노드가 해야할 명령 수행하고 노드 상태등을 마스터로 전달

kube-proxy - 노드로 들어오는 트래픽을 적절한 컨테이너로 라우팅. 로드밸런싱등 노드로 들어오고 나가는 트래픽을 프록시하고 노드-마스터 간의 통신 관리

### 오브젝트

가장 기본적인 pod, service, volume, namespace 4가지가 있다.

#### pod

가장 기본적인 배포단위로 컨테이너를 포함하는 단위. 여러 컨테이너 포함.

파드내의 컨테이너는 ip와 포트 공유. 또한 디스크 볼륨 공유

#### volume

pod가 기동할때 디폴트로, 컨테이너마다 로컬 디스크를 생성해서 기동. but 영구적이지 못함. 그래서 파일을 영속적으로 저장하기 위한 스토리지를 두는데 그것을 볼륨이라고 한다.

#### service

pod를 서비스로 제공할때, 여러개의 pod를 서비스 하면서, 로드밸런서를 이용하여 하나의 ip와 port로 묶어 서비스 제공. 파드는 장애시 재시작되고, 동적으로 생성되서 ip가 변하기 때문에 로드밸런서에서 pod지정시 ip로하긴 어려움. 그래서 label, label selector 이용

* emptyDir : pod 생성시 생성, 삭제시 삭제되는 임시볼륨.

* hostPath : 로컬디스크의 경로를 pod에서 마운트해서 사용. pod 재시작하여 다른 노드 기동시, 그노드 hostpath 사용하기 때문에 액세스 불가.
* persistentVolume and persitentVolumeClaim: 시스템 관리자가 실제 물리디스크 생성 후 이 디스크를 pv라는 이름으로 쿠버네티스에 등록.개발자는 pvc를 지정하여 pv에 연결

#### namespace

한 쿠버네티스 클러스터의 논리적인 분리단위. 사용자별로 네임스페이스별 접근 권한 달리 운영가능. 리소스의 할당량 지정 가능. 리소스 (파드, 서비스)등을 나눠서 관리할 수 있다.

논리적인 단위이므로 다른 네임스페이스간 pod라도 통신 가능

### 라벨

라벨은 쿠버네티스의 리소스 선택하는데 사용이 됨. 리소스는 라벨을 가질 수 있고, 라벨검색 조건에 따라 특정 리소스만 선택가능. 여러개의 라벨 동시적용 가능.

### 컨트롤러

#### replica controller

pod 관리해주는 역할, 지정된 숫자로 pod 실행,관리.

* selector: 라벨을 기반으로, rc가 관리한 pod 가지고오는데 사용
* replica 수: rc에 관리되는 pod의 수
* 어떻게 pod를 만들지 pod에 대한 정보를 pod template 부분에 정의

#### replicaSet

rc의 새버전.

큰 차이는 없고 Replication Controller 는 Equality 기반 Selector를 이용하는데 반해, Replica Set은 Set 기반의 Selector를 이용

#### Deployment

위의 2개 보다 좀더 상위 추상화 개념.

블루그린 배포: 블루버전 서비스를 그린버전으로 새롭게 배포후 트래픽을 한번에 돌리는 방식

롤링업그레이드: 파드를 하나씩 업그레이드 해나가는 방식

#### DaemonSet

pod가 각 노드에서 하나씩만 돌게하는 형태로 관리하는 컨트롤러. 주로 서버 모니터링이나 로그 수집용도로 사용

#### Job

배치나 한번실행되고 끝나는 형태의 작업에 사용.job에 의해 관리되는 pod는 job종료시 같이 종료

#### StatefulSet

데이터베이스와 같이 상태를 가지는 애플리케이션 관리를 위해 사용.

loadbalancing: 하나의 서비스가 발생하는 트래픽이 많을때 여러 대의 서버가 분산처리하여 해결해주는 서비스

### SERVICE TYPE

* loadbalancer: 외부 ip를 가지고 있는 로드밸런서 할당.
* cluserIP: 디폴트 설정으로, 서비스에 클러스터 ip(내부 ip) 할당. 외부에서 접근 불가.
* nodeport: 노드의 ip와 port를 통해서 접근.
* externalname: 외부서비스를 쿠버네티스 내부에서 호출시 사용 가능.

### INGRESS

서비스 앞에 붙어서 다른 서비스로 라우팅해줌. 사용하려면 nodeport 타입으로 배포

### 헬스체크

* liveness probe: 컨테이너 생존 여부 체크
* readiness probe: 서비스 가능 상태 체크

probe types

* command probe: 쉘 명령을 수행후 여부 체크
* http probe: http get을 이용하여 상태체크
* tcp probe: tcp 연결 시도후 판단

### 모니터링

#### cAdvisor

각 노드마다 설치되서 노드에 대한 정보를 수집하여 kubelet으로 전달

#### heapster

수집된 지표는 heapster라는 시스템에 모이게되고, heapster는 수집된 지표를 백엔드에 저장.

모티터링 대시보드는 쿠버대스보드 or 프로메테우스 + 그라파나